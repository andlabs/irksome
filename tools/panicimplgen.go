// 28 january 2015
package main

import (
	"fmt"
	"os"
	"go/token"
	"go/parser"
	"go/ast"
	"golang.org/x/tools/go/types"
	_ "golang.org/x/tools/go/gcimporter"
	"bytes"
	"text/template"
	"go/format"
	"io/ioutil"
)

const outTemplate = `// generated by tools/panicimplgen.go; do not edit
package {{.PackageName}}
{{$input := .}}{{range .Methods}}
func ({{$input.FirstChar}} {{$input.TypeName}}) {{.Name}}{{.Args}}{{.Returns}} {
	panic("attempt to call {{.Name}}() method of {{$input.PackageName}}.{{$input.PublicName}}")
}
{{end}}`

type method struct {
	Name	string
	Args		string
	Returns	string
}

type outParams struct {
	PackageName	string
	TypeName	string
	PublicName	string
	FirstChar		string
	Methods		[]method
}

func die(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format, args...)
	fmt.Fprintf(os.Stderr, "\n")
	os.Exit(1)
}

func main() {
	if len(os.Args) != 7 {
		die("usage: %s pkgpath pkgname typeToImpl outputVar outputType outfile", os.Args[0])
		os.Exit(1)
	}

	pkgpath := os.Args[1]
	pkgname := os.Args[2]
	typeToImpl := os.Args[3]
	outputVar := os.Args[4]
	outputType := os.Args[5]
	outfile := os.Args[6]

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, pkgpath, nil, parser.AllErrors)
	if err != nil {
		die("error parsing package: %v", err)
	}
	pkg, ok := pkgs[pkgname]
	if !ok {
		die("package %s not found in directory %s", pkgname, pkgpath)
	}
	// pkg.FIles is a map of ast.Files; we need a slice
	files := make([]*ast.File, 0, len(pkg.Files))
	for _, f := range pkg.Files {
		files = append(files, f)
	}

	// and FINALLY we can get the interface info
	// TODO pkgname should really be the fully qualified path
	p, err := types.Check(pkgname, fset, files)
	if err != nil {
		die("error getting type information of package: %v", err)
	}
	obj := p.Scope().Lookup(typeToImpl)
	if obj == nil {
		die("type %s not in package", typeToImpl)
	}
	named, ok := obj.Type().(*types.Named)
	if !ok {
		die("type %s is not a named type (is a %T)", typeToImpl, obj.Type())
	}
	iface, ok := named.Underlying().(*types.Interface)
	if !ok {
		die("type %s is not an interface (is a %T)", typeToImpl, named.Underlying())
	}

	methods := make([]method, 0, iface.NumMethods())
	for i := 0; i < iface.NumMethods(); i++ {
		m := iface.Method(i)
		sig := m.Type().(*types.Signature)
		args := "()"
		rets := ""
		if a := sig.Params(); a != nil {
			args = types.TypeString(p, a)
		}
		if r := sig.Results(); r != nil {
			rets = " " + types.TypeString(p, r)
		}
		methods = append(methods, method{
			Name:	m.Name(),
			Args:	args,
			Returns:	rets,
		})
	}

	buf := new(bytes.Buffer)
	t, err := template.New("outTemplate").Parse(outTemplate)
	if err != nil {
		die("error parsing output template: %v", err)
	}
	err = t.Execute(buf, &outParams{
		PackageName:		pkgname,
		TypeName:		outputType,
		PublicName:		outputVar,
		FirstChar:			string([]rune(outputType)[0]),
		Methods:			methods,
	})
	if err != nil {
		die("error generating output file: %v", err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		die("error formatting output file: %v\noutput:\n%s", err, buf.String())
	}
	err = ioutil.WriteFile(outfile, formatted, 0644)
	if err != nil {
		die("error writing output file: %v", err)
	}
}
